# フェーズ2.1: 面子型定義の学習記録

## 実装日: 2024-06-30

## 学習目標
関数型DDDにおける型設計と、ドメインルールの正確な表現方法を学ぶ。

## 主要な学習ポイント

### 1. スマートコンストラクタパターンの限界と実践

#### 初期実装の問題
```fsharp
type Meld = private Meld of MeldType

// 同一モジュール内では不正作成が可能
let invalid = Meld(Sequence(tile1, tile5, tile9)) // 検証なし！
```

#### 学んだこと
- F#の`private`コンストラクタはスコープベースの制限
- 完全な不正インスタンス化防止は困難
- 実用的な妥協点を見つけることが重要

#### 結論
- 過度なカプセル化は複雑性を増すだけ
- シンプルな`private`コンストラクタ + スマートコンストラクタで十分
- コードレビューとテストで補完

### 2. 型システムの表現力の限界

#### 表現できないドメインルール
```fsharp
type MeldType =
    | Sequence of Tile * Tile * Tile // "連続する3牌"は型で表現不可
    | Triplet of Tile * Tile * Tile  // "同じ3牌"は型で表現不可
```

#### 実際の制約実装
```fsharp
// 型レベル: 牌の個数のみ保証
// 実行時: ドメインルールを検証
let tryCreateSequence tiles =
    if isConsecutive tiles then Ok(...) else Error(...)
```

#### 学んだこと
- F#の型システムでは「連続性」「同一性」は表現できない
- 実行時検証が必要なドメインルールは存在する
- 型安全性と実用性のバランスが重要

### 3. ドメイン駆動設計での正確な命名

#### 初期の誤った命名
```fsharp
type Head = Head of Tile * Tile  // "頭"と決めつけ
```

#### 修正後の正確な命名
```fsharp
type Pair = Pair of Tile * Tile  // 客観的事実
```

#### 学んだこと
- `Pair`は状態（2枚の同じ牌）
- `Head`は役割（和了形での雀頭）
- シャボ待ちでは和了まで雀頭は確定しない
- 命名は文脈に依存しない客観的事実を表すべき

### 4. モジュール設計と責任の分離

#### 初期設計の問題
```fsharp
// Meld.fs に面子とペアが混在
module Meld =
    type MeldType = Sequence | Triplet  // 面子
    type PairType = Pair                // 面子ではない！
```

#### 改善後の設計
```text
Meld.fs - 面子（3牌の組み合わせ）のみ
Pair.fs - ペア（2牌の組み合わせ）のみ
```

#### 学んだこと
- 単一責任の原則は関数型でも重要
- ドメインの概念ごとにモジュールを分離
- 将来の拡張性を考慮した設計

## 技術的な発見

### Result型の役割と限界
- Result型は「操作の成功/失敗」を表現
- 成功時の値の内部制約は表現できない
- エラーハンドリングの明示化には有効

### 関数合成によるAPI簡潔化
```fsharp
// Before: 3つの検出関数
findAllSequences, findAllTriplets, findAllPairs

// After: 2つの明確な関数
findAllMelds  // 面子（順子+刻子）
findAllPairs  // ペア
```

## 今後の課題

1. **型安全性の向上**
   - Phantom Typesの活用検討
   - より表現力のある型設計の探求

2. **和了判定への準備**
   - 4面子1雀頭の組み合わせ検証
   - 効率的なアルゴリズムの検討

## まとめ

フェーズ2.1では、型システムの限界を理解しつつ、実用的で保守しやすい設計を実現した。完璧を求めすぎず、ドメインルールを正確に表現する適切なバランスを見つけることが重要だと学んだ。特に、命名の重要性と、モジュール分離による責任の明確化が、長期的な保守性に大きく貢献することを実感した。