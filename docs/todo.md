# 麻雀で学ぶ関数型ドメインモデリング - 学習進行TODO

## フェーズ1: Tile型定義 → Hand管理
**学習目標：型安全性とドメイン表現**

### 1.1 基本型定義 ✅
- [x] Tile型の定義（萬子、筒子、索子、字牌）
- [x] 不正な牌（萬子の10など）をコンパイル時に防ぐ設計
- [x] 基本的なTile作成関数とバリデーション

### 1.2 Hand管理 ✅
- [x] Hand型の定義（14牌の制約）
- [x] 手牌の基本操作（追加、削除、ソート）
- [x] Result型を使ったエラーハンドリング

### 1.3 テストとバリデーション ✅
- [x] TileモジュールとHandモジュールの包括的テスト
- [x] パラメータ化テストの実装
- [x] ドメインが仕様であることの実践
- [x] 予測可能な設計への改善

**習得スキル**
- [x] 型駆動設計の実践
- [x] 不変性の活用
- [x] Value Objectパターン
- [x] 基本的なResult型バリデーション
- [x] 関数型プログラミングでのテスト設計

---

## フェーズ2: Meld検出 → Winning hand判定
**学習目標：関数合成とパターンマッチング**

### 2.1 Meld型定義
- [x] 順子（Sequence）型の定義と検出関数
- [x] 刻子（Triplet）型の定義と検出関数
- [x] 雀頭（Pair）型の定義と検出関数

### 2.2 面子分解（小さいPRに分割）

#### PR1: 基本的な面子分解 ✅
- [x] MeldDecompositionモジュールの作成
- [x] tryDecompose関数（14牌→Option<Meld list * Pair>）の基本実装
- [x] Option型を使った面子の存在表現
- [x] シンプルなケースのテスト（明確に4面子1雀頭になるケース）

#### PR2: 完全な面子分解 ✅
- [x] バックトラッキングによる全組み合わせ探索

#### PR3: 複数分解パターン対応 ✅
- [x] 全ての有効な分解パターンを返す関数の実装
- [x] 複数パターンが存在する手牌のテストケース

### 2.3 和了判定 ✅
- [x] 有効な面子組み合わせの検証
- [x] 和了形の判定関数
- [x] テストケース（和了手、ノーテン手）

**習得スキル**
- [x] 関数分解技法
- [x] 合成可能な設計
- [x] パターンマッチングの活用
- [x] Maybe/Option型の活用

---

## フェーズ3: 基本役判定 → 複合役
**学習目標：ドメインロジックの実装とOption型の活用**

### 3.1 基本役の実装（小さいPRに分割）

#### PR1: タンヤオ実装 ✅
- [x] Yaku.fs作成（型定義、エラー型）
- [x] タンヤオ（中張牌のみ）の判定
- [x] タンヤオのテスト実装

#### PR2: 面子構成系の役
- [x] ピンフ（順子4つ+雀頭）の判定
- [x] トイトイ（刻子4つ）の判定

#### PR3: 牌の種類系の役
- [x] ホンイツ（一色+字牌）の判定
- [x] チンイツ（一色のみ）の判定

#### PR4: YakuAnalyzer実装 ✅
- [x] YakuAnalyzer.fs作成（役の合成と分析）
- [x] 複数役の並列判定
- [x] Railway-Oriented Programmingの実践
- [x] 複数役の組み合わせ検証
- [x] 役なし（ノーテン）の処理
- [x] 統合テスト（複数役の組み合わせ）

#### PR5: 全分解パターン対応（予期しない実装）✅
- [x] ピンフ役判定の全分解パターン対応
- [x] トイトイ役判定の全分解パターン対応
- [x] 複数分解パターンを持つ手牌のテストケース追加

#### PR6-1: 一盃口の基本実装
- [x] 一盃口（同じ順子2つ）の役定義追加
- [x] 同じ順子2組の検出ロジック実装
- [x] 一盃口の基本的なテストケース追加
- [x] 全分解パターン対応の確認

#### PR6-2: 高点法の実装 ✅
- [x] Yaku型に翻数（fan）フィールド追加
- [x] 各役の翻数定義（一盃口:1翻、トイトイ:2翻など）
- [x] 相互排他関係の定義（一盃口⇔トイトイ）
- [x] 複数の役組み合わせから最高点選択ロジック実装
- [x] 111222333mRRRGGのような相互排他が発生するケースのテスト
- [x] 高点法の一般的なテストケース追加

---

## フェーズ5: リーチ宣言の実装
**学習目標：Railway-Oriented Programming の実践**

### 5.1 テンパイ判定の実装 ✅
- [x] TenpaiAnalyzer モジュールの作成
- [x] isTenpai関数の実装（13牌からテンパイ判定）
- [x] 待ち牌リストの取得関数
- [x] テンパイ判定のテストケース実装
- [x] パターンベースのテンパイ検出（両面・嵌張・辺張・双碰・単騎）
- [x] 複合パターン対応（1112形、1113形、1112345形）
- [x] 純正九蓮宝燈対応（9種全待ち）
- [x] MeldDecomposition重複除去による性能最適化

### 5.2 リーチドメインの実装 ✅
- [x] ReachContext型の定義（プレイヤー点数、ゲーム段階、リーチ状態）
- [x] ReachError型の定義（ドメイン特化エラー）
- [x] ReachDeclaration型の定義（宣言結果）
- [x] Turn型とScore型のValue Object実装（制約付き）
- [x] 標準Result型による型安全なエラーハンドリング設計

### 5.3 Railway-Oriented Programming の実践 ✅
- [x] リーチ宣言バリデーションパイプラインの実装
- [x] テンパイチェック → 点数チェック → ゲーム段階チェックのResult型チェーン
- [x] bind (>>=) 演算子による関数合成
- [x] パラメーター注入による外部状態管理
- [x] 個別バリデーション関数の実装（checkTenpai, checkScore, checkGameStage, checkReachStatus）
- [x] declareReach メイン関数の実装（Result型チェーン）
- [x] 包括的テストケース実装（成功/失敗シナリオ、パラメータ化テスト）

### 5.4 エラー集約パターンの実装 ✅
- [x] Validation.fsモジュールの作成（エラー集約ユーティリティ）
- [x] sequence関数の実装（Result<'a, 'e> list -> Result<'a list, 'e list>）
- [x] traverse関数の実装（関数適用と結果集約）
- [x] apply関数とApplicative演算子（<*>）の実装
- [x] validateAll関数の実装（並列バリデーション実行）
- [x] declareReachWithAllErrors関数の実装（エラー集約版リーチ宣言）
- [x] 既存declareReach関数の互換性維持（fail-fast方式）
- [x] liftError関数の実装（単一エラー→エラーリスト変換）


**習得スキル**
- [x] **パターンベース分析**: 複数分解パターンの正確な検出
- [x] **関数型アルゴリズム**: 再帰とバックトラッキングの最適化
- [x] **性能改善**: 組み合わせ生成の重複除去（5000パターン→数十パターン）
- [x] **複雑度対応**: 純正九蓮宝燈など最高難度パターンの処理
- [x] **Railway-Oriented Programming の実践**: Result型チェーンによるバリデーションパイプライン
- [x] **Result型チェーンによるエラー伝播**: bind演算子による関数合成
- [x] **ドメイン特化エラーハンドリング**: ReachErrorによる明示的エラー表現
- [x] **パラメーター注入による外部状態管理**: ReachContextによる依存関係処理
- [x] **Applicativeパターンの実装**: 独立したバリデーションの並列実行
- [x] **エラー集約パターンの実装**: 全エラー収集によるUX改善
- [x] **MonadとApplicativeの使い分け**: 依存関係の有無による適切な選択

---

## 完了チェック

### 全体的な習得確認
- [ ] 型安全性：不正な状態をコンパイル時に防げている
- [ ] 関数合成：小さな関数を組み合わせて複雑なロジックを構築
- [ ] エラーハンドリング：Railway-Oriented Programmingを実践
- [ ] ドメイン表現：麻雀のルールがコードに直接表現されている
- [ ] テスト：各フェーズで適切なテストケースを作成

### 次のステップ（拡張課題）
- [ ] 変形役（七対子、国士無双）の追加
- [ ] ゲーム状態役（リーチ、一発）の追加
- [ ] 符計算の実装
- [ ] 親子概念の追加
- [ ] ドラの実装

## メモ・学習記録

### フェーズ1.1完了 (2024-06-29)
- **実装内容**: Tile型の完全な定義とバリデーション機能
- **学習成果**: 
  - 型駆動設計により萬子の10などの不正な牌をコンパイル時に防げることを確認
  - プライベートコンストラクタとスマートコンストラクタによるValue Objectパターンの実装
  - Result型による明示的なエラーハンドリング（Railway-Oriented Programming の基礎）
- **追加実装**: 
  - 牌の比較関数（ソート機能用）
  - 文字列パース機能（"1m", "2p", "E"など）
- **次の課題**: Hand型でこれらの基礎を活用した14牌制約の実装

### フェーズ1.3完了 (2024-06-30)
- **実装内容**: TileとHandモジュールの包括的テスト実装（92テストケース）
- **学習成果**:
  - ドメイン実装が仕様であることの実践
  - パラメータ化テスト（Theory/InlineData）による効率的なテスト設計
  - 順序依存を排除した予測可能な設計への改善
- **設計改善**: 文字列解析を文字数で明確に区別（1文字=風牌、2文字=数牌/三元牌）
- **次の課題**: フェーズ2（面子検出と和了判定）

### フェーズ2.2 PR1完了 (2025-01-02)
- **実装内容**: 基本的な面子分解機能（14牌→4面子1雀頭への分解）
- **学習成果**:
  - DDDにおける責務の適切な配置（Hand.tryDecomposeとして実装）
  - Option型による安全な値の表現とnull回避
  - F#の関数合成（パイプライン演算子、高階関数）の実践
  - `function`キーワードとタプルによるF#らしい記法
- **設計判断**: 
  - MeldDecompositionを内部モジュールとして分離
  - シンプルな貪欲法で基本実装（バックトラッキングは将来のPR）
  - テストアサーションの具体化と予測可能性の向上
- **次の課題**: PR2（バックトラッキングによる完全な面子分解）

### フェーズ2.2 PR2完了 (2025-01-04)
- **実装内容**: バックトラッキングによる完全な面子分解
- **学習成果**:
  - 貪欲法からバックトラッキングアルゴリズムへの改善
  - F#関数型プログラミングの実践（match式、再帰処理、アキュムレータパターン）
  - パラメータ化テスト（Theory/InlineData）による効率的なテスト設計
  - 一盃口、重なる順子など複雑なパターンの理解
- **技術判断**:
  - if-elseからmatch式への改善で可読性向上
  - インデックス除去による純粋関数的アプローチ
  - 関数配置の最適化（宣言と使用箇所を近づける）
- **テスト追加**: 22234567m、112233m、234456mパターン
- **次の課題**: PR3（複数分解パターン対応、エッジケース、パフォーマンステスト）

### フェーズ2.3完了 (2025-01-08)
- **実装内容**: 和了判定機能（isWinningHand関数）
- **学習成果**:
  - 既存の面子分解ロジックを活用した簡潔な実装
  - 関数合成の実践（tryDecomposeAllの結果を判定に利用）
  - 包括的なテストケース設計（和了手10種、ノーテン手8種、13牌手1種）
  - テストケースの可読性向上（無関係な牌を字牌に統一）
- **設計判断**:
  - bool返却のシンプルな判定関数（将来的にOption/Result型への拡張も可能）
  - 複雑な面子分解ロジックは既に完成しているため、薄いラッパー関数として実装
- **次の課題**: フェーズ3（基本役判定）

### フェーズ3.1 PR1完了 (2025-01-09)
- **実装内容**: タンヤオ（All Simples）の役判定機能
- **学習成果**:
  - Yaku型の設計（将来の拡張を考慮したDU型）
  - YakuError型によるドメイン特化エラーハンドリング
  - 関数合成の実践（isTerminalTile → checkTanyao → analyzeYaku）
  - Result型を使った安全なエラーハンドリング
  - 包括的なテストケース設計（成功ケース6種、失敗ケース4種）
- **設計判断**:
  - 中張牌判定の純粋関数化（副作用なし）
  - 将来の役追加を考慮した拡張可能な設計
  - List.head を match式に置き換えた安全な実装
- **次の課題**: フェーズ3.1 PR2（面子構成系の役：ピンフ、トイトイ）

### フェーズ5.1完了 (2025-01-14)
- **実装内容**: 包括的なテンパイ検出システム（280テストケース完全成功）
- **学習成果**:
  - **パターンベース分析**: TenpaiPattern型による明確な分解表現（FourMeldsWait, ThreeMeldsOnePairWait）
  - **複数分解対応**: 1手牌から複数の有効分解パターンを正確に検出し、全待ち牌を算出
  - **アルゴリズム最適化**: combinations関数による重複除去で5000+パターン→数十パターンに削減
  - **複雑パターン対応**: 純正九蓮宝燈（9種全待ち）まで完璧に処理
  - **型安全性**: IncompletePattern（Ryanmen, Kanchan, Penchan, Shanpon）による待ちパターンの厳密な表現
- **技術的成果**:
  - **関数型アルゴリズム**: 再帰的組み合わせ生成とバックトラッキングの効率的な実装
  - **分離設計**: MeldDecomposition（面子分解）とTenpaiAnalyzer（テンパイ分析）の責務分離
  - **性能最適化**: インデックス順序固定による重複なし組み合わせ生成
  - **テスト駆動**: 単純パターンから複合パターンまで段階的なテストケース設計
- **デバッグ手法**: 複雑なバグを単純化による問題特定（複合パターン→単純パターン）
- **麻雀知識**: 七対子・国士無双の仕様外確認、4面子1雀頭形式への統一
- **次の課題**: フェーズ5.2（リーチドメインの実装）

### フェーズ5.3完了 (2025-01-16)
- **実装内容**: Railway-Oriented Programming を活用したリーチ宣言バリデーションシステム
- **学習成果**:
  - **バリデーションパイプライン**: checkTenpai → checkScore → checkGameStage → checkReachStatus の順次実行
  - **Result型チェーン**: Result.bind による関数合成でエラー短絡評価を実現
  - **個別責務分離**: 各バリデーションを独立した純粋関数として実装
  - **外部状態管理**: ReachContext によるパラメーター注入パターン
  - **ドメイン特化エラー**: ReachError による明示的エラー表現（NotTenpai, InsufficientScore等）
- **技術的成果**:
  - **Railway-Oriented Programming**: Scott Wlaschin のパターンを実践
  - **関数合成**: bind 演算子による宣言的なパイプライン構築
  - **型安全性**: コンパイル時エラー検出による堅牢な設計
  - **テスト駆動**: 成功/失敗シナリオ12テスト、パラメータ化テスト実装
- **設計判断**:
  - **単一エラー方式**: フェーズ5.3では fail-fast 方式を採用（エラー集約は5.4で実装）
  - **Value Object**: Turn, Score による制約付きドメインオブジェクト
  - **関数分離**: バリデーションロジックとビジネスロジック（determineReachResult）の分離
- **テスト結果**: 全293テスト成功（既存テスト含む）
- **次の課題**: フェーズ5.4（エラー集約パターンの実装）

### フェーズ5.4完了
- **実装内容**: Applicativeパターンによるエラー集約バリデーションシステム
- **学習成果**:
  - **Applicativeパターン**: 独立したバリデーションの並列実行による効率化
  - **エラー集約**: 全バリデーションエラーを同時収集し、ユーザビリティを向上
  - **MonadとApplicativeの使い分け**: 依存関係の有無による適切なパターン選択
  - **関数型ユーティリティ**: sequence, traverse, apply等の汎用的な関数合成
  - **型安全なエラーハンドリング**: Result<'T, 'Error list>による複数エラー表現
- **技術的成果**:
  - **Validation.fs**: エラー集約専用モジュールの完全実装
  - **並列バリデーション**: 4つの独立したチェックを同時実行
  - **Applicative演算子**: apply（<*>）による宣言的な関数合成
  - **後方互換性**: 既存fail-fast方式を維持しつつ新機能追加
  - **包括的テスト**: 18新規テスト追加、全308テスト成功
  - **テストケース実装**: 成功・失敗・エラー集約パターンの完全網羅
- **設計判断**:
  - **2つのアプローチ提供**: declareReach（fail-fast）とdeclareReachWithAllErrors（集約）
  - **自前実装**: 外部ライブラリに依存せず、学習効果を最大化
  - **関数型原則**: 純粋関数による副作用のない実装
  - **型レベル安全性**: コンパイル時にエラー処理の正確性を保証
- **実用価値**: WebフォームやAPIバリデーションなど、実世界でのエラーハンドリングに直接応用可能
- **次の課題**: 拡張課題（フェーズ6以降）または他のドメイン機能の実装
