# 麻雀で学ぶ関数型ドメインモデリング - 学習進行TODO

## フェーズ1: Tile型定義 → Hand管理
**学習目標：型安全性とドメイン表現**

### 1.1 基本型定義 ✅
- [x] Tile型の定義（萬子、筒子、索子、字牌）
- [x] 不正な牌（萬子の10など）をコンパイル時に防ぐ設計
- [x] 基本的なTile作成関数とバリデーション

### 1.2 Hand管理 ✅
- [x] Hand型の定義（14牌の制約）
- [x] 手牌の基本操作（追加、削除、ソート）
- [x] Result型を使ったエラーハンドリング

### 1.3 テストとバリデーション ✅
- [x] TileモジュールとHandモジュールの包括的テスト
- [x] パラメータ化テストの実装
- [x] ドメインが仕様であることの実践
- [x] 予測可能な設計への改善

**習得スキル**
- [x] 型駆動設計の実践
- [x] 不変性の活用
- [x] Value Objectパターン
- [x] 基本的なResult型バリデーション
- [x] 関数型プログラミングでのテスト設計

---

## フェーズ2: Meld検出 → Winning hand判定
**学習目標：関数合成とパターンマッチング**

### 2.1 Meld型定義
- [x] 順子（Sequence）型の定義と検出関数
- [x] 刻子（Triplet）型の定義と検出関数
- [x] 雀頭（Pair）型の定義と検出関数

### 2.2 面子分解（小さいPRに分割）

#### PR1: 基本的な面子分解 ✅
- [x] MeldDecompositionモジュールの作成
- [x] tryDecompose関数（14牌→Option<Meld list * Pair>）の基本実装
- [x] Option型を使った面子の存在表現
- [x] シンプルなケースのテスト（明確に4面子1雀頭になるケース）

#### PR2: 完全な面子分解 ✅
- [x] バックトラッキングによる全組み合わせ探索

#### PR3: 複数分解パターン対応 ✅
- [x] 全ての有効な分解パターンを返す関数の実装
- [x] 複数パターンが存在する手牌のテストケース

### 2.3 和了判定 ✅
- [x] 有効な面子組み合わせの検証
- [x] 和了形の判定関数
- [x] テストケース（和了手、ノーテン手）

**習得スキル**
- [x] 関数分解技法
- [x] 合成可能な設計
- [x] パターンマッチングの活用
- [x] Maybe/Option型の活用

---

## フェーズ3: 基本役判定 → 複合役
**学習目標：Railway-Oriented Programming**

### 3.1 基本役の実装（小さいPRに分割）

#### PR1: タンヤオ実装 ✅
- [x] Yaku.fs作成（型定義、エラー型）
- [x] タンヤオ（中張牌のみ）の判定
- [x] タンヤオのテスト実装

#### PR2: 面子構成系の役
- [x] ピンフ（順子4つ+雀頭）の判定
- [x] トイトイ（刻子4つ）の判定

#### PR3: 牌の種類系の役
- [x] ホンイツ（一色+字牌）の判定
- [x] チンイツ（一色のみ）の判定

#### PR4: YakuAnalyzer実装
- [ ] YakuAnalyzer.fs作成（役の合成と分析）
- [ ] 複数役の並列判定
- [ ] Railway-Oriented Programmingの実践
- [ ] 複数役の組み合わせ検証
- [ ] 役なし（ノーテン）の処理
- [ ] 統合テスト（複数役の組み合わせ）

### 3.2 エラーハンドリングの高度化
- [ ] 役判定のResult型チェーン
- [ ] 複数バリデーションの合成
- [ ] ドメインエラーの明確な表現
- [ ] エラー集約パターンの実装

**習得スキル**
- [ ] Railway-Oriented Programming
- [ ] エラー合成パターン
- [ ] 型安全なエラーハンドリング
- [ ] 複数のバリデーション結果の合成

---

## フェーズ4: 点数計算 → 特殊役
**学習目標：ワークフローとドメインイベント**

### 4.1 翻数計算
- [ ] 各役の翻数定義
- [ ] 役リストから翻数合計の計算
- [ ] 40符固定での点数計算ワークフロー

### 4.2 特殊ケース
- [ ] 役満の処理（大三元、四暗刻など）
- [ ] 複合不可の役の処理
- [ ] 最高点役の選択ロジック

### 4.3 ワークフロー設計
- [ ] 手牌→役判定→点数計算の一連の流れ
- [ ] 副作用の分離と制御
- [ ] ドメインイベントによる結果の表現

**習得スキル**
- [ ] ワークフロー設計
- [ ] 副作用管理
- [ ] ドメインイベントパターン
- [ ] 高階関数による柔軟な計算ロジック

---

## 完了チェック

### 全体的な習得確認
- [ ] 型安全性：不正な状態をコンパイル時に防げている
- [ ] 関数合成：小さな関数を組み合わせて複雑なロジックを構築
- [ ] エラーハンドリング：Railway-Oriented Programmingを実践
- [ ] ドメイン表現：麻雀のルールがコードに直接表現されている
- [ ] テスト：各フェーズで適切なテストケースを作成
- [ ] パフォーマンス：関数型アプローチでも実用的な速度

### 次のステップ（拡張課題）
- [ ] 変形役（七対子、国士無双）の追加
- [ ] ゲーム状態役（リーチ、一発）の追加
- [ ] 符計算の実装
- [ ] 親子概念の追加
- [ ] ドラの実装

## メモ・学習記録

### フェーズ1.1完了 (2024-06-29)
- **実装内容**: Tile型の完全な定義とバリデーション機能
- **学習成果**: 
  - 型駆動設計により萬子の10などの不正な牌をコンパイル時に防げることを確認
  - プライベートコンストラクタとスマートコンストラクタによるValue Objectパターンの実装
  - Result型による明示的なエラーハンドリング（Railway-Oriented Programming の基礎）
- **追加実装**: 
  - 牌の比較関数（ソート機能用）
  - 文字列パース機能（"1m", "2p", "E"など）
- **次の課題**: Hand型でこれらの基礎を活用した14牌制約の実装

### フェーズ1.3完了 (2024-06-30)
- **実装内容**: TileとHandモジュールの包括的テスト実装（92テストケース）
- **学習成果**:
  - ドメイン実装が仕様であることの実践
  - パラメータ化テスト（Theory/InlineData）による効率的なテスト設計
  - 順序依存を排除した予測可能な設計への改善
- **設計改善**: 文字列解析を文字数で明確に区別（1文字=風牌、2文字=数牌/三元牌）
- **次の課題**: フェーズ2（面子検出と和了判定）

### フェーズ2.2 PR1完了 (2025-01-02)
- **実装内容**: 基本的な面子分解機能（14牌→4面子1雀頭への分解）
- **学習成果**:
  - DDDにおける責務の適切な配置（Hand.tryDecomposeとして実装）
  - Option型による安全な値の表現とnull回避
  - F#の関数合成（パイプライン演算子、高階関数）の実践
  - `function`キーワードとタプルによるF#らしい記法
- **設計判断**: 
  - MeldDecompositionを内部モジュールとして分離
  - シンプルな貪欲法で基本実装（バックトラッキングは将来のPR）
  - テストアサーションの具体化と予測可能性の向上
- **次の課題**: PR2（バックトラッキングによる完全な面子分解）

### フェーズ2.2 PR2完了 (2025-01-04)
- **実装内容**: バックトラッキングによる完全な面子分解
- **学習成果**:
  - 貪欲法からバックトラッキングアルゴリズムへの改善
  - F#関数型プログラミングの実践（match式、再帰処理、アキュムレータパターン）
  - パラメータ化テスト（Theory/InlineData）による効率的なテスト設計
  - 一盃口、重なる順子など複雑なパターンの理解
- **技術判断**:
  - if-elseからmatch式への改善で可読性向上
  - インデックス除去による純粋関数的アプローチ
  - 関数配置の最適化（宣言と使用箇所を近づける）
- **テスト追加**: 22234567m、112233m、234456mパターン
- **次の課題**: PR3（複数分解パターン対応、エッジケース、パフォーマンステスト）

### フェーズ2.3完了 (2025-01-08)
- **実装内容**: 和了判定機能（isWinningHand関数）
- **学習成果**:
  - 既存の面子分解ロジックを活用した簡潔な実装
  - 関数合成の実践（tryDecomposeAllの結果を判定に利用）
  - 包括的なテストケース設計（和了手10種、ノーテン手8種、13牌手1種）
  - テストケースの可読性向上（無関係な牌を字牌に統一）
- **設計判断**:
  - bool返却のシンプルな判定関数（将来的にOption/Result型への拡張も可能）
  - 複雑な面子分解ロジックは既に完成しているため、薄いラッパー関数として実装
- **次の課題**: フェーズ3（基本役判定）

### フェーズ3.1 PR1完了 (2025-01-09)
- **実装内容**: タンヤオ（All Simples）の役判定機能
- **学習成果**:
  - Yaku型の設計（将来の拡張を考慮したDU型）
  - YakuError型によるドメイン特化エラーハンドリング
  - 関数合成の実践（isTerminalTile → checkTanyao → analyzeYaku）
  - Result型を使った安全なエラーハンドリング
  - 包括的なテストケース設計（成功ケース6種、失敗ケース4種）
- **設計判断**:
  - 中張牌判定の純粋関数化（副作用なし）
  - 将来の役追加を考慮した拡張可能な設計
  - List.head を match式に置き換えた安全な実装
- **次の課題**: フェーズ3.1 PR2（面子構成系の役：ピンフ、トイトイ）
